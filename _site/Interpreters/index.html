<!DOCTYPE html>
<html>
  <head>
    <title>An Introduction to Interpreters – Andrew Wei – </title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="This blog post introduces the world of interpreters with an example in Golang.
The code comes from the book Writing An Interpreter In Go by Thorsten Ball.
" />
    <meta property="og:description" content="This blog post introduces the world of interpreters with an example in Golang.
The code comes from the book Writing An Interpreter In Go by Thorsten Ball.
" />
    
    <meta name="author" content="Andrew Wei" />

    
    <meta property="og:title" content="An Introduction to Interpreters" />
    <meta property="twitter:title" content="An Introduction to Interpreters" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Andrew Wei - " href="/feed.xml" />

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://avatars0.githubusercontent.com/u/8172167?s=400&u=27034bc93779390bfbaca21727973a54058fc093&v=4" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Andrew Wei</a></h1>
            <p class="site-description"></p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {
  inlineMath: [['$','$'], ['\\(','\\)']],
  processEscapes: true},
  jax: ["input/TeX","input/MathML","input/AsciiMath","output/CommonHTML"],
  extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "[Contrib]/a11y/accessibility-menu.js"],
  TeX: {
  extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"],
  equationNumbers: {
  autoNumber: "AMS"
  }
  }
  });
  </script>
<article class="post">
  <h1>An Introduction to Interpreters</h1>

  <div class="date">
    Written on January 18, 2021
  </div>
  <div class="entry">
    <p>This blog post introduces the world of interpreters with an example in Golang.
The code comes from the book <a href="https://interpreterbook.com/">Writing An Interpreter In Go</a> by Thorsten Ball.</p>

<p>This is a relatively long blog post that divides up the parts of an interpreter into three main parts: lexing, parsing, and evaluation.
Check out the post outline for links to specific sections and subsections to get a better overall picture of how each of the pieces fit together.</p>

<h2 id="post-outline">Post Outline</h2>
<ul>
  <li><a href="#what-is-an-interpreter">What is an Interpreter?</a></li>
  <li><a href="#what-are-the-pieces-involved">What are the pieces involved?</a></li>
  <li><a href="#tokens-and-lexing">Tokens and Lexing</a>
    <ul>
      <li><a href="#tokens">Tokens</a></li>
      <li><a href="#lexer">Lexer</a></li>
    </ul>
  </li>
  <li><a href="#parsing-into-an-ast">Parsing into an AST</a>
    <ul>
      <li><a href="#the-abstract-syntax-tree">The Abstract Syntax Tree</a></li>
      <li><a href="#parsing">Parsing</a></li>
    </ul>
  </li>
  <li><a href="#evaluating-the-ast">Evaluating the AST</a></li>
  <li><a href="#putting-everything-together">Putting Everything Together</a></li>
  <li><a href="#resources">Resources</a></li>
</ul>

<h2 id="what-is-an-interpreter">What is an Interpreter</h2>
<p>Interpreters take in source code for a program and output the results of running the program.
Interpreters produce output by directly executing the instructions specified in the source code. This stands in contrast to compilers, which generate an intermediate representation of the program to be compiled into machine code that is then executed.
Here is a diagram that provides a contrasting visualization.</p>

<p><img src="/images/Interpreters/compilerVsInterpreter.png" alt="_config.yml" /></p>

<p><a href="https://www.guru99.com/difference-compiler-vs-interpreter.html">Source</a></p>

<p>An example interpreter is the Python interpreter in the command line. 
We can type any valid Python statement into the interpreter and will get the output immediately.
One interesting point to note about Python is that in <a href="https://github.com/python/cpython">CPython</a>, the standard implementation of Python, Python source code is compiled into Python bytecode, which itself is then interpreted.</p>

<p><img src="/images/Interpreters/pythonInterpreter.png" alt="_config.yml" /></p>

<p>Note that the Python compiler is on the complex side of interpreters. 
CPython applies many optimizations and compiles to bytecode among other features. 
Simple interpreters would interpret the input right away without any optimizations.
The code covered in “Writing an Interpreter in Go” lies in the middle; the source code is transformed into a tree (not bytecode on the complex side) and evaluated.
The source code is not directly evaluated as on the simpler side.</p>

<h2 id="what-are-the-pieces-involved">What are the pieces involved</h2>

<p>A process called lexical analysis is performed by a <strong>lexer</strong> that converts input source code into a sequence of <strong>tokens</strong>.</p>

<p>A <strong>parser</strong> then takes these tokens from the lexer’s outputs to generate an <strong>Abstract Syntax Tree (AST)</strong>, which is a representation of the source code that the computer can understand.</p>

<p>An <strong>evaluator</strong> takes in and recursively traverses the AST to generate the program’s output.</p>

<h2 id="tokens-and-lexing">Tokens and Lexing</h2>

<h3 id="tokens">Tokens</h3>
<p>The first step is to convert the source code into a sequence of tokens using a lexer. 
But first, what is a token? 
Tokens represent every little piece of the programming language. 
In the token definition for the Monkey Language (as presented in the book), tokens can be numbers, strings, identifiers (i.e. variables), keywords (e.g. if, return, function), operators (e.g. =, +) and more. 
Take a look at the <a href="">token.go</a> file for all the types of tokens.</p>

<p>In Monkey, a token is represented as a struct:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Token struct {
   Type    TokenType
   Literal string
}
</code></pre></div></div>

<p>In this framework, all we need to know to represent a token is its type (i.e. TokenType) and what the actual value (i.e. literal) is. 
For example, a TokenType could be an ASSIGN operator and the literal would be the string “=”.</p>

<h3 id="lexer">Lexer</h3>

<p>Now that we have defined the format of the basic blocks that we want to break our source code into, we will use a lexer that takes in the source code and spits out a sequence of tokens that represent the source code. 
The pattern used is very similar to the iterator concept, as can be encountered in Java or C++. 
Another program that wants to read the source code can iterate through the source code represented as a series of tokens by calling a type of <code class="language-plaintext highlighter-rouge">next</code> method. 
The lexer, as represented in the struct code shown below, acts as the “iterator” for the source code.
The lexer takes in the source code as a string, represented by the <code class="language-plaintext highlighter-rouge">input</code> field.</p>

<p>The lexer as represented in the code is also a struct, just like the <code class="language-plaintext highlighter-rouge">Token</code> struct. (note that Golang provides structs instead of classes). 
The struct has the following member variables. 
The <code class="language-plaintext highlighter-rouge">input</code> variable of type <code class="language-plaintext highlighter-rouge">string</code> represents the input source code as a single string. 
The <code class="language-plaintext highlighter-rouge">position</code>, <code class="language-plaintext highlighter-rouge">readPosition</code>, and <code class="language-plaintext highlighter-rouge">ch</code> variables are used to keep track of how much of the source code the lexer has read so far.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Lexer struct {
   input        string
   position     int  // current position in input (points to current char)
   readPosition int  // current reading position in input (after current char)
   ch           byte // current char under examination
}
</code></pre></div></div>

<p>There is a <code class="language-plaintext highlighter-rouge">New(input string)</code> function for the struct that creates a new struct (note that Golang is a garbage collected language; the programmer does not have to deallocate memory like in C for example).</p>

<p>The interpreter reads from the sequence of tokens by calling the lexer’s <code class="language-plaintext highlighter-rouge">NextToken()</code> method.
This method is akin to the <code class="language-plaintext highlighter-rouge">Next()</code> function in the iterator pattern in Java and C++.
Calling <code class="language-plaintext highlighter-rouge">aLexerStruct.NextToken()</code> will return the next token to be processed, starting with the first token and advancing one at a time until reaching the last token.
The <code class="language-plaintext highlighter-rouge">NextToken()</code> is essentially a huge glorified switch statement with a few extra bells and whistles.
The function uses the <code class="language-plaintext highlighter-rouge">ch</code> field to get the next character of the source code to read in.</p>

<p>For example, if the next character read in is <code class="language-plaintext highlighter-rouge">+</code>, a plus sign, a new token of type PLUS will be returned.
A more complicated example is determining if the character is part of a keyword or a user defined variable.
If the next token is a letter, the function will read in the rest of the word (if there are any).
The function will then call a function <code class="language-plaintext highlighter-rouge">LookupIdent(ident string)</code> defined in <code class="language-plaintext highlighter-rouge">token.go</code> that determines if the word is a keyword type (e.g. let) and if not, defines the word to be an identifier type (i.e. variable).
Note that whitespace is ignored by calling the struct’s function <code class="language-plaintext highlighter-rouge">skipWhitespace()</code> in <code class="language-plaintext highlighter-rouge">NextToken()</code>.</p>

<h2 id="parsing-into-an-ast">Parsing into an AST</h2>

<h3 id="the-abstract-syntax-tree">The Abstract Syntax Tree</h3>
<p>Now that we have a way of turning our input source code for the <code class="language-plaintext highlighter-rouge">Monkey</code> language into a sequence of Token structs, we will use a parser to turn that sequence into an internal representation for the computer to work with.
This internal representation is called an AST, which stands for Abstract Syntax Tree.
This can be thought of as a hierarchical tree representation of the source code.</p>

<p><img src="/images/Interpreters/ast.png" alt="_config.yml" /></p>

<p><a href="https://interpreterbook.com/">Source</a></p>

<p>An Abstract Syntax Tree, like other trees in computer science, are made up of nodes.
Each node represents a small piece of the entire program, like a variable declaration or a return statement.
In <code class="language-plaintext highlighter-rouge">Monkey</code>, there are two general categories of pieces: statements and expressions.
An example of a statement is <code class="language-plaintext highlighter-rouge">let x = 5</code>.
An example of an expression can be <code class="language-plaintext highlighter-rouge">1 + 2</code>, or a function call that produces a value like <code class="language-plaintext highlighter-rouge">timesTwo(4)</code>.
The general rule is that expressions produce values while statements don’t.
A list of statements make up a program, as defined in the <code class="language-plaintext highlighter-rouge">Program</code> struct.</p>

<p>Statements and Expressions are represented as interfaces.
Golang doesn’t support class inheritance (there are no classes in Golang) but it does support embedding, which can solve some of the same design problems.
Embedding can be used to add an interface within another interface to add all of the functions declared in the inner interface to the outer interface.
In this case, we are embedding interfaces.
For example, both the <code class="language-plaintext highlighter-rouge">Statement</code> and the <code class="language-plaintext highlighter-rouge">Expression</code> interfaces have the base <code class="language-plaintext highlighter-rouge">Node</code> interface embedded within.</p>

<h4 id="examples">Examples</h4>

<p>To further understand the concepts of a Statement and an Expression, lets delve into an example for each.
In <code class="language-plaintext highlighter-rouge">Monkey</code>, a return statement is a type of statement.
It is represented as a struct:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type ReturnStatement struct {
	Token       token.Token // the 'return' token
	ReturnValue Expression
}
</code></pre></div></div>

<p>We can see that the <code class="language-plaintext highlighter-rouge">ReturnStatement</code> struct has a field for the return value, which is of type <code class="language-plaintext highlighter-rouge">Expression</code>.
This makes sense because the return statement must return a value, and expressions are values.</p>

<p>A more complicated example are <code class="language-plaintext highlighter-rouge">let</code>statements, which assign values to identifiers.
They are represented with the following struct:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type LetStatement struct {
	Token token.Token // the token.LET token
	Name  *Identifier
	Value Expression
}
</code></pre></div></div>

<p>A trivial example of an Expression would be a number, represented as an <code class="language-plaintext highlighter-rouge">IntegerLiteral</code> struct:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type IntegerLiteral struct {
	Token token.Token
	Value int64
}
</code></pre></div></div>

<p>A slightly more complicated example is the representation for infix expressions.
Infix expressions take on the following form: x &lt;infix operator&gt; y.
For example, the addition can be an infix operator if used in the following manner: <code class="language-plaintext highlighter-rouge">1 + 2</code>.
It is represented by the <code class="language-plaintext highlighter-rouge">InfixExpression</code> like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type InfixExpression struct {
	Token    token.Token // The operator token, e.g. +
	Left     Expression
	Operator string
	Right    Expression
}
</code></pre></div></div>

<h3 id="parsing">Parsing</h3>

<p>The parser is represented as a struct that contains several fields.
One important field is the <code class="language-plaintext highlighter-rouge">lexer</code>, which was what we discussed previously: a struct that exposes a <code class="language-plaintext highlighter-rouge">NextToken()</code> function to iterate through the pieces of the input source code.
Other important fields include the <code class="language-plaintext highlighter-rouge">curToken</code> and the <code class="language-plaintext highlighter-rouge">peekToken</code> fields which keep track of where the parser is in terms of the tokenized source code.</p>

<p>We will go over the function that is called to parse the whole program, aptly named <code class="language-plaintext highlighter-rouge">ParseProgram()</code>.
We will then delve into a couple helper functions, <code class="language-plaintext highlighter-rouge">parseLetStatement()</code> and <code class="language-plaintext highlighter-rouge">parseExpressionStatement()</code>, to solidify our understanding of how the tokens are turned into the AST representation discussed previously.
Note that an expression statement is simply a line in the source code that gives a value without doing anything with it.
A trivial example would be the number 5 on its own line, which is a value (an expression) percieved as a statement (a line in the code which in this case does nothing).</p>

<h4 id="parse-the-whole-program">Parse the whole program</h4>

<p>The way the <code class="language-plaintext highlighter-rouge">ParseProgram()</code> function works is that it continues attempting to parse all the tokens in the source code in a for loop.
Note that this does not mean that the function visits each successive token at each iteration.
The loop, while being called a <code class="language-plaintext highlighter-rouge">for</code> loop, acts more like a <code class="language-plaintext highlighter-rouge">while</code> loop that continues executing the loop body until the End of File token is reached, signaling that the program is completely finished executing.
The body of the for loop parses the statements out of the sequence of tokens and adds them to the <code class="language-plaintext highlighter-rouge">Statements</code> field of the newly created <code class="language-plaintext highlighter-rouge">Program</code> struct to return at the end.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (p *Parser) ParseProgram() *ast.Program {
	program := &amp;ast.Program{}
	program.Statements = []ast.Statement{}

	for !p.curTokenIs(token.EOF) {
		stmt := p.parseStatement()
		if stmt != nil {
			program.Statements = append(program.Statements, stmt)
		}
		p.nextToken()
	}

	return program
}
</code></pre></div></div>

<p>The way the parser determines that a contiguous subset of the sequence of tokens is a statement is through a helper function called <code class="language-plaintext highlighter-rouge">parseStatement()</code>.
This function is a switch statement that determines if the current subset is a <code class="language-plaintext highlighter-rouge">let</code> statement, a <code class="language-plaintext highlighter-rouge">return</code> statement, or an <code class="language-plaintext highlighter-rouge">expression</code> statement.
It then calls the appropriate helper function.
We will go over the parser helper functions for the <code class="language-plaintext highlighter-rouge">let</code> and <code class="language-plaintext highlighter-rouge">expression</code> statements.</p>

<h4 id="example-parse-a-let-statement">Example: parse a let statement</h4>

<p>The <code class="language-plaintext highlighter-rouge">parseLetStatement()</code> function first creates a new let statement struct to be fill in and return at the end.
It then checks to see if the next token after the <code class="language-plaintext highlighter-rouge">let</code> token is an identifier (i.e. the name of a variable).
If not, the function returns nil.
The function then updates the <code class="language-plaintext highlighter-rouge">name</code> field of the <code class="language-plaintext highlighter-rouge">LetStatement</code> struct and then checks to confirm if the next token is the ASSIGN token (i.e. <code class="language-plaintext highlighter-rouge">=</code>) and returns nil of not.
Finally, it is time to parse the expression that is being assigned to the identifier.
The value of the identifier is returned in the helper function <code class="language-plaintext highlighter-rouge">p.parseExpression</code>, which is covered in the next example.
Afterwards, the value is set inside of the <code class="language-plaintext highlighter-rouge">LetStatement</code> struct.
Since semi colons are optional in <code class="language-plaintext highlighter-rouge">Monkey</code>, there is a final check to see if the token after all the pieces of the let statement have been parsed is a semi colon and iterate past it if so.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (p *Parser) parseLetStatement() *ast.LetStatement {
	stmt := &amp;ast.LetStatement{Token: p.curToken}

	if !p.expectPeek(token.IDENT) {
		return nil
	}

	stmt.Name = &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}

	if !p.expectPeek(token.ASSIGN) {
		return nil
	}

	p.nextToken()

	stmt.Value = p.parseExpression(LOWEST)

	if p.peekTokenIs(token.SEMICOLON) {
		p.nextToken()
	}

	return stmt
}
</code></pre></div></div>

<h4 id="example-parse-an-expression">Example: parse an expression</h4>

<p>When parsing expressions, we will use a technique called <strong>Pratt Parsing</strong>.</p>

<p>To understand pratt parsing’s strategy, lets take a look at the <code class="language-plaintext highlighter-rouge">-</code> token (i.e. the minus token).
This token can be used either to represent a negative number (e.g. <code class="language-plaintext highlighter-rouge">-1</code>) or a subtraction operation (e.g. 5 - 2).
The first representation is part of a prefix expression while the second representation is part of an infix expression.</p>

<p>Note on the other hand the <code class="language-plaintext highlighter-rouge">!</code> token (i.e. the bang token).
This is used to represent the not operator for booleans.
It is possible to write <code class="language-plaintext highlighter-rouge">! cond</code> (i.e. a prefix expression) but not to write <code class="language-plaintext highlighter-rouge">x ! y</code> (i.e. an infix expression).</p>

<p>The idea behind Pratt parsing is that each of these operator (e.g. <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">!</code>) tokens can be associated with being part of an infix or a prefix expression if valid.
It depends on what the source code says.</p>

<p>The function that parses expressions is called <code class="language-plaintext highlighter-rouge">parseExpressionStatement()</code>.
This is essentially a wrapper function that calls <code class="language-plaintext highlighter-rouge">parseExpression()</code>, where the core of the parsing occurs.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (p *Parser) parseExpression(precedence int) ast.Expression {
	prefix := p.prefixParseFns[p.curToken.Type]
	if prefix == nil {
		p.noPrefixParseFnError(p.curToken.Type)
		return nil
	}
	leftExp := prefix()

	for !p.peekTokenIs(token.SEMICOLON) &amp;&amp; precedence &lt; p.peekPrecedence() {
		infix := p.infixParseFns[p.peekToken.Type]
		if infix == nil {
			return leftExp
		}

		p.nextToken()

		leftExp = infix(leftExp)
	}

	return leftExp
}
</code></pre></div></div>

<p>The first thing the function does is check if the next token is a prefix expression or not (e.g. <code class="language-plaintext highlighter-rouge">=</code>, the equal sign).
If not, an error is logged and the function returns.
If the next token is a prefix, we return that later on in the function.</p>

<p>Then, there is a loop that essentially parses the rest of the expression (as signified by the semi colon).
The loop has two conditions: one involving the semi colon (signaling termination) and the other involving precedence
Precedence is an integral part of parsing.
We see a precedence check in the second condition of the loop in <code class="language-plaintext highlighter-rouge">parseExpression()</code>.
<code class="language-plaintext highlighter-rouge">Monkey</code> defines precedences in the following order.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const (
	_ int = iota
	LOWEST
	EQUALS      // ==
	LESSGREATER // &gt; or &lt;
	SUM         // +
	PRODUCT     // *
	PREFIX      // -X or !X
	CALL        // myFunction(X)
	INDEX       // array[index]
)
</code></pre></div></div>

<p>This hierarchy is used throughout the parsing to check for precedence (i.e. in what order to parse the tokens).</p>

<p>Now let’s analyze the body of the loop.
First there is a check to see if the next token is a infix operation or not.
If the next expression is not an infix operation, return the left expression (which would indicate that the prefix expression which just a value).
The left expression is calculated by calling the respective prefix expressions registered in the <code class="language-plaintext highlighter-rouge">New()</code> method of the <code class="language-plaintext highlighter-rouge">Parser</code> struct.</p>

<p>For example, we could return a boolean value if the leftExp was a boolean.
Now for a more complicated prefix example.
If our expression was <code class="language-plaintext highlighter-rouge">-5</code>, then <code class="language-plaintext highlighter-rouge">parsePrefixExpression()</code> would be called with the negative being set in the associated <code class="language-plaintext highlighter-rouge">PrefixExpression</code> struct (as defined in the AST).
Then, <code class="language-plaintext highlighter-rouge">parseExpression()</code> is recursively called on the next token.
In this case, our next token is <code class="language-plaintext highlighter-rouge">5</code> and the call would result in <code class="language-plaintext highlighter-rouge">parseIntegerLiteral()</code> being called. 
This would then result in having the <code class="language-plaintext highlighter-rouge">Right</code> expression-typed field in the <code class="language-plaintext highlighter-rouge">PrefixExpression</code> struct set to the <code class="language-plaintext highlighter-rouge">IntegerLiteral</code>.</p>

<p>On the other hand, if the next token is an infix operation, then <code class="language-plaintext highlighter-rouge">nextToken()</code> is called.
This function advances the lexer (i.e. the source code’s iterator) by a single token.
Then when infix is called, it calls <code class="language-plaintext highlighter-rouge">parseInfixExpression()</code> with the left expression as input (as that is what the particular token was mapped to in the <code class="language-plaintext highlighter-rouge">New()</code> function).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {
	expression := &amp;ast.InfixExpression{
		Token:    p.curToken,
		Operator: p.curToken.Literal,
		Left:     left,
	}

	precedence := p.curPrecedence()
	p.nextToken()
	expression.Right = p.parseExpression(precedence)

	return expression
}
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">parseInfixExpression()</code> takes in the left value of the infix expression, parses the right expression by calling and returns the expression struct
(gets the right expression by recursively calling the parseExpression() function).</p>

<p>When we finally return back to the type parseExpression, the output will have been a subtree of the AST tree representing the parsed expression.</p>

<h2 id="evaluating-the-ast">Evaluating the AST</h2>

<p>The code for evaluating the <code class="language-plaintext highlighter-rouge">AST</code> that is returned by the parser is in <code class="language-plaintext highlighter-rouge">evaluator.go</code>.
The main function has the signature: <code class="language-plaintext highlighter-rouge">func Eval(node ast.Node, env *object.Environment) object.Object</code>.
The first parameter is an <code class="language-plaintext highlighter-rouge">ast.Node</code>, which, when first called, will be the entire program represented by <code class="language-plaintext highlighter-rouge">ast.Program</code>.
We will see this later in the <code class="language-plaintext highlighter-rouge">repl</code> that the user directly interacts with in the last section.
The other parameter is a pointer to an <code class="language-plaintext highlighter-rouge">object.Environment</code>.
The environment stores all the particular variables declared so far in the current program.
This is important because if we have initialized a particular variable to be of a certain value, we want to remember that for later on when we want to use that variable.
The output is a generic <code class="language-plaintext highlighter-rouge">object.Object</code>.
For example, this could be a value if some value is returned or nil of nothing is returned.</p>

<p>The body of the <code class="language-plaintext highlighter-rouge">Eval</code> function is essentially a giant switch statement that executes a different block depending on the specific subclass type of the input <code class="language-plaintext highlighter-rouge">ast.Node</code>.
This is because <code class="language-plaintext highlighter-rouge">Eval</code> is called recursively by certain cases.
For example, if the input <code class="language-plaintext highlighter-rouge">ast.Node</code> was a return statement, the expression representing the value of the return statement would also be passed through <code class="language-plaintext highlighter-rouge">Eval</code>.</p>

<p>Let’s take a look at the case where the input is of type <code class="language-plaintext highlighter-rouge">ast.Program</code>.
In this case, the <code class="language-plaintext highlighter-rouge">evalProgram</code> function is called.
The <code class="language-plaintext highlighter-rouge">evalProgram</code> function loops through each statement in the program and calls <code class="language-plaintext highlighter-rouge">Eval</code> on them.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func evalProgram(program *ast.Program, env *object.Environment) object.Object {
	var result object.Object

	for _, statement := range program.Statements {
		result = Eval(statement, env)

		switch result := result.(type) {
		case *object.ReturnValue:
			return result.Value
		case *object.Error:
			return result
		}
	}

	return result
}
</code></pre></div></div>

<p>We go back to the <code class="language-plaintext highlighter-rouge">Eval</code> function.
Notice that the cases span every possible statement in <code class="language-plaintext highlighter-rouge">Monkey</code>.
Let’s see a couple examples.
There is a <code class="language-plaintext highlighter-rouge">let</code> case for defining variables (they are saved to the environment) as shown below.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val := Eval(node.Value, env)
if isError(val) {
    return val
}
env.Set(node.Name.Value, val)
</code></pre></div></div>

<p>There is a function <code class="language-plaintext highlighter-rouge">evalInfixExpression()</code> if the statement was an infix expression.
The function has a switch statement that covers every possible type of infix operator and performs the operation.
Note that if the inputs are integers, the function <code class="language-plaintext highlighter-rouge">evalIntegerInfixExpression()</code> is called, which is yet another switch statement that performs operations such as multiplication, addition, and so on.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func evalInfixExpression(
	operator string,
	left, right object.Object,
) object.Object {
	switch {
	case left.Type() == object.INTEGER_OBJ &amp;&amp; right.Type() == object.INTEGER_OBJ:
		return evalIntegerInfixExpression(operator, left, right)
	case left.Type() == object.STRING_OBJ &amp;&amp; right.Type() == object.STRING_OBJ:
		return evalStringInfixExpression(operator, left, right)
	case operator == "==":
		return nativeBoolToBooleanObject(left == right)
	case operator == "!=":
		return nativeBoolToBooleanObject(left != right)
	case left.Type() != right.Type():
		return newError("type mismatch: %s %s %s",
			left.Type(), operator, right.Type())
	default:
		return newError("unknown operator: %s %s %s",
			left.Type(), operator, right.Type())
	}
}
</code></pre></div></div>

<h2 id="putting-everything-together">Putting Everything Together</h2>
<p>To see all the parts fitting together, let’s take a look at the <code class="language-plaintext highlighter-rouge">Start()</code> function in <code class="language-plaintext highlighter-rouge">repl.go</code>, which is called by <code class="language-plaintext highlighter-rouge">main.go</code> when the interpreter starts up.
The repl is responsible for continuously reading in the user’s input program, executing it, and returning the output.</p>

<p>If we look inside the for loop, we can see that first the prompt is printed and then a scanner is called to read in the user’s code as a string.
A <code class="language-plaintext highlighter-rouge">lexer</code> created with the source code.
A <code class="language-plaintext highlighter-rouge">parser</code> is then created with the iterator associated with the source code.
The <code class="language-plaintext highlighter-rouge">ParseProgram()</code> function, as covered previously, is then called to turn the sequence of tokens produced by the <code class="language-plaintext highlighter-rouge">lexer</code> into an <code class="language-plaintext highlighter-rouge">AST</code>.
Assuming no errors, the <code class="language-plaintext highlighter-rouge">evaluator</code> calls <code class="language-plaintext highlighter-rouge">Eval()</code> on the input program.
If the result is not <code class="language-plaintext highlighter-rouge">nil</code>, it is printed for the user.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func Start(in io.Reader, out io.Writer) {
	scanner := bufio.NewScanner(in)
	env := object.NewEnvironment()

	for {
		fmt.Printf(PROMPT)
		scanned := scanner.Scan()
		if !scanned {
			return
		}

		line := scanner.Text()
		l := lexer.New(line)
		p := parser.New(l)

		program := p.ParseProgram()
		if len(p.Errors()) != 0 {
			printParserErrors(out, p.Errors())
			continue
		}

		evaluated := evaluator.Eval(program, env)
		if evaluated != nil {
			io.WriteString(out, evaluated.Inspect())
			io.WriteString(out, "\n")
		}
	}
}
</code></pre></div></div>

<h2 id="running-the-code">Running the code</h2>
<p>The code from <a href="https://interpreterbook.com/">Writing An Interpreter In Go by Thorsten Ball</a> can be found in <a href="https://github.com/andrew128/waiig_code">this repo</a>.
To run a test, navigate to the <code class="language-plaintext highlighter-rouge">src/monkey</code> directory and run <code class="language-plaintext highlighter-rouge">go test ./&lt;test name&gt;</code>.
For example, running the test for <code class="language-plaintext highlighter-rouge">ast</code> would be <code class="language-plaintext highlighter-rouge">go test ./ast</code>.
To run the actual <code class="language-plaintext highlighter-rouge">Monkey</code> interpreter, navigate to the <code class="language-plaintext highlighter-rouge">src/monkey</code> directory and run <code class="language-plaintext highlighter-rouge">go run main.go</code>.</p>

<h2 id="resources">Resources</h2>
<ul>
  <li><a href="https://interpreterbook.com/">Writing An Interpreter In Go by Thorsten Ball</a></li>
  <li><a href="https://nedbatchelder.com/blog/201803/is_python_interpreted_or_compiled_yes.html">Is Python Interpreted or Compiled</a></li>
</ul>

  </div>


  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/andrew128"><i class="svg-icon github"></i></a>

<a href="https://www.linkedin.com/in/andrew-wei-272027147/"><i class="svg-icon linkedin"></i></a>






        </footer>
      </div>
    </div>

    
	<!-- Google Analytics -->
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-177211139-1', 'auto');
		ga('send', 'pageview', {
		  'page': '/Interpreters/',
		  'title': 'An Introduction to Interpreters'
		});
	</script>
	<!-- End Google Analytics -->


  </body>
</html>
