<!DOCTYPE html>
<html>
  <head>
    <title>C Source Code to x86 Binary – Andrew Wei – </title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="This blog post details how C source code is compiled into x86 binary.
" />
    <meta property="og:description" content="This blog post details how C source code is compiled into x86 binary.
" />
    
    <meta name="author" content="Andrew Wei" />

    
    <meta property="og:title" content="C Source Code to x86 Binary" />
    <meta property="twitter:title" content="C Source Code to x86 Binary" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Andrew Wei - " href="/feed.xml" />

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://avatars0.githubusercontent.com/u/8172167?s=400&u=27034bc93779390bfbaca21727973a54058fc093&v=4" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Andrew Wei</a></h1>
            <p class="site-description"></p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {
  inlineMath: [['$','$'], ['\\(','\\)']],
  processEscapes: true},
  jax: ["input/TeX","input/MathML","input/AsciiMath","output/CommonHTML"],
  extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "[Contrib]/a11y/accessibility-menu.js"],
  TeX: {
  extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"],
  equationNumbers: {
  autoNumber: "AMS"
  }
  }
  });
  </script>
<article class="post">
  <h1>C Source Code to x86 Binary</h1>

  <div class="date">
    Written on January 12, 2021
  </div>
  <div class="entry">
    <p>This blog post details how C source code is compiled into x86 binary.</p>

<h2 id="post-outline">Post Outline</h2>
<ul>
  <li><a href="#source-code-to-executable">Source Code to Executable</a>
    <ul>
      <li><a href="#preprocessor-and-compiler">Preprocessor and Compiler</a></li>
      <li><a href="#calling-conventions-aside">Calling Conventions Aside</a></li>
      <li><a href="#assembler-and-linker">Assembler and Linker</a></li>
      <li><a href="#dynamic-linking-vs-static-linking-aside">Dynamic Linking vs Static Linking Aside</a></li>
      <li><a href="#static-library-vs-shared-library-aside">Static Library vs Shared Library Aside</a></li>
    </ul>
  </li>
  <li><a href="#executable-format">Executable Format</a>
    <ul>
      <li><a href="#elf-header">ELF Header</a></li>
      <li><a href="#program-headers">Program Headers</a></li>
      <li><a href="#section-headers">Section Headers</a></li>
    </ul>
  </li>
  <li><a href="#program-execution">Program Execution</a></li>
  <li><a href="#resources">Resources</a></li>
</ul>

<h2 id="source-code-to-executable">Source Code to Executable</h2>

<p>How is a program (specifically in C) that someone writes understood and executed by the computer?
This is a multistep process that turns the source code, written by the programmer, into machine code, which can be executed by the machine.
We will follow the process with the example C code below.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;

int main() {
    int x = 1 + 2;
    printf("Hello world!\n");
    return 0;
}
</code></pre></div></div>

<p>Here is an image detailing the whole process.</p>

<p><img src="/images/x86BinaryBlog/compilationProcess.png" alt="_config.yml" />
<a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html">Source</a></p>

<h3 id="preprocessor-and-compiler">Preprocessor and Compiler</h3>
<p>First, the source code is put through a <strong>preprocessor</strong>.
In the case of the C code, this could be including header files and expanding macros.
Then, a <strong>compiler</strong> parses the source code and turns it into an Abstract Syntax Tree, an internal representation of the program.
The compiler then puts the code through many different intermediate representations that each optimize the code (e.g. removing unused code, loop unrolling).
The result of the compiler is assembly code, which is still human readable.</p>

<h3 id="calling-conventions-aside">Calling Conventions Aside</h3>
<p>Below is the assembly representation of the above example C code.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000000000001135 &lt;main&gt;:
    1135:	55                   	push   %rbp
    1136:	48 89 e5             	mov    %rsp,%rbp
    1139:	48 83 ec 10          	sub    $0x10,%rsp
    113d:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%rbp)
    1144:	48 8d 3d b9 0e 00 00 	lea    0xeb9(%rip),%rdi        # 2004 &lt;_IO_stdin_used+0x4&gt;
    114b:	e8 e0 fe ff ff       	callq  1030 &lt;puts@plt&gt;
    1150:	b8 00 00 00 00       	mov    $0x0,%eax
    1155:	c9                   	leaveq
    1156:	c3                   	retq
    1157:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    115e:	00 00
</code></pre></div></div>

<p>We can see the C language calling conventions in the snippet.
There is a <code class="language-plaintext highlighter-rouge">__libc_start_main()</code> function that initializes the execution environment and calls the <code class="language-plaintext highlighter-rouge">main()</code> function with the appropriate arguments.
We can see the standard subroutine prologue, body, and epilogue in the assembly code.
Below is an image of the stack in memory during the execution of some function with three input parameters and a local variable.
Note that the architecture below is 32 bit so the registers start with <code class="language-plaintext highlighter-rouge">e</code> as opposed to <code class="language-plaintext highlighter-rouge">r</code>.</p>

<p><img src="/images/x86BinaryBlog/callingConventions.png" alt="_config.yml" />
<a href="https://aaronbloomfield.github.io/pdr/book/x86-32bit-ccc-chapter.pdf">Source</a></p>

<h4 id="subroutine-prologue">Subroutine Prologue</h4>
<p>First, we push the old base pointer value stored in <code class="language-plaintext highlighter-rouge">%rbp</code>, the register for the base pointer, onto the stack.
Then we move the value that the stack pointer <code class="language-plaintext highlighter-rouge">%rsp</code> is pointing to into <code class="language-plaintext highlighter-rouge">%rbp</code>’s address.
There is then a <code class="language-plaintext highlighter-rouge">sub $0x10,%rsp</code>, which moves our stack pointer down the stack with some space between the saved value of the <code class="language-plaintext highlighter-rouge">%rbp</code> base pointer.
This middle space will contain local variables that will be filled in the subroutine body.</p>

<h4 id="subroutine-body">Subroutine Body</h4>

<p>We see that the value <code class="language-plaintext highlighter-rouge">0x3</code> is moved into <code class="language-plaintext highlighter-rouge">-0x4(%rbp)</code>, the location of the local variable x.
We also see that there is a <code class="language-plaintext highlighter-rouge">puts()</code> call where we might have expected a <code class="language-plaintext highlighter-rouge">printf()</code> call.
This is because the compiler saw that we were not passing in any parameters to <code class="language-plaintext highlighter-rouge">printf()</code> and called <code class="language-plaintext highlighter-rouge">puts()</code> instead, which only takes a single argument.</p>

<p>We also see that the value <code class="language-plaintext highlighter-rouge">0x0</code> is moved into the register <code class="language-plaintext highlighter-rouge">%eax</code>.
The register <code class="language-plaintext highlighter-rouge">%eax</code> stores the return value, which in this case is <code class="language-plaintext highlighter-rouge">0</code> as can be seen in the source code.</p>

<h4 id="subroutine-epilogue">Subroutine Epilogue</h4>
<p>We see there a <code class="language-plaintext highlighter-rouge">leaveq</code> instruction.
At this point in the function, we have finished our work in the current function being called (i.e. the callee) and want to return to the previous function (i.e. the caller).
Therefore, we want to deallocate our local variables and restore our base pointer, which marks the start of a function’s stack frame to its previous value.
Both of the above actions are done with the <code class="language-plaintext highlighter-rouge">leaveq</code> instruction, which copies the frame pointer in the <code class="language-plaintext highlighter-rouge">%rbp</code> register into the stack pointer <code class="language-plaintext highlighter-rouge">%rsp</code>.
This releases the stack space allocated by the stack frame.
The <code class="language-plaintext highlighter-rouge">leaveq</code> instruction then pops the value pointed to by <code class="language-plaintext highlighter-rouge">%rsp</code> into <code class="language-plaintext highlighter-rouge">%rbp</code> and thus restoring the calling procedure’s stack frame</p>

<p>Note that the <code class="language-plaintext highlighter-rouge">leaveq</code> instruction is functionally equivalent to the instructions <code class="language-plaintext highlighter-rouge">mov %rsp, %rbp</code> and <code class="language-plaintext highlighter-rouge">pop %ebp</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">leaveq</code> is then followed by a <code class="language-plaintext highlighter-rouge">retq</code> instruction.
At the point that the <code class="language-plaintext highlighter-rouge">retq</code> instruction is being executed, the stack pointer <code class="language-plaintext highlighter-rouge">%rsp</code> points to the address 4 bytes above the saved value of <code class="language-plaintext highlighter-rouge">%rbp</code>, which is the return address of the next instruction in the callee function’s code to be executed.
The <code class="language-plaintext highlighter-rouge">retq</code> instruction pops the return address from the stack into the instruction pointer <code class="language-plaintext highlighter-rouge">%rip</code>, which points to the next instruction to be executed.
Thus the program will resume executing at the saved return address (which was pushed onto the stack by the caller function).</p>

<p>Note that the <code class="language-plaintext highlighter-rouge">NOPW</code> is a no-op instruction, which stands for no operation.
The instruction does nothing but simply takes up a word sized byte for alignment purposes so that a code sequence ends on a particular memory boundary.</p>

<h3 id="assembler-and-linker">Assembler and Linker</h3>
<p>To turn the assembly code into machine code, there is an <strong>assembler</strong> that generates a binary object file.
Then, a <strong>static linker</strong> looks at the main binary and resolves any imports that the main binary might need, creating another binary object file that includes all the required static libraries.
Note that there is also <strong>dynamic linking</strong>, which is when shared libraries are imported at run time.
Also note that when people say compile they generally mean the entire process: preprocessing, compiling, assembling, and linking.</p>

<h3 id="dynamic-linking-vs-static-linking-aside">Dynamic Linking vs Static Linking Aside</h3>
<p>In static linking, the entire library of a function that the main program is using is copied over and compiled, which may result in a lot of unnecessary bloat.
Dynamic linking solves this problem by linking the libraries that the main program requires at run time.
The downside is that while compilation time and resulting binary size is decreased, running time is increased because of the need to import functions being used during runtime.</p>

<p>In our code, we have <code class="language-plaintext highlighter-rouge">#include &lt;stdio.h&gt;</code>.
This line uses the <code class="language-plaintext highlighter-rouge">#include</code> preprocessor to tell the compiler what libraries to import.
On Linux, C standard libraries like <code class="language-plaintext highlighter-rouge">stdio</code> are by default linked dynamically.</p>

<h3 id="static-library-vs-shared-library-aside">Static Library vs Shared Library Aside</h3>
<p>When program is linked against a static library, machine code from the object files for any external functions used by the program is copied from the library into the final executable.</p>

<p>A shared library is handled with dynamic linking, which makes the executable file smaller than if the library were static.
Dynamic linking works by including only the functions that the main executable requires (instead of the complete machine code from the object files for the external functions that a static library would include).
Before the executable file starts running, the machine code for the external functions is copied into memory from the shared library file on disk by the OS.
The advantage is that the library can be updated without recompiling the programs which use it.
With dynamic linking of shared libraries, one copy of a library can be shared between multiple programs.</p>

<h2 id="executable-format">Executable Format</h2>

<p>Note that this blog post specifically covers compilation on x86 processors, specifically x86-64 (the 64 bit version).
The term x86 refers to a family of instruction set architectures.
An instruction set architecture can be thought of as an abstract model of a computer.
It specifies the architecture and the programming environment that processors supporting x86 must support, including the instruction set supported, the types of registers, and the data types.
A CPU is an example of an implementation of an instruction set architecture.</p>

<p>On x86 processors, the ELF format (Executable and Linkable Format) is the standard binary file format.
This ELF file is the output of the assembler as described in the process above.</p>

<p><img src="/images/x86BinaryBlog/elfFile.png" alt="_config.yml" />
<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Source</a></p>

<p>We can view our program’s elf binary after the entire compilation process using <code class="language-plaintext highlighter-rouge">readelf -e playground</code>.</p>

<h3 id="elf-header">ELF Header</h3>
<p><img src="/images/x86BinaryBlog/elfHeader.png" alt="_config.yml" /></p>

<p>ELF files have three parts: the elf header, section headers, and program headers.
The elf header general information about the binary, such as the byte ordering (i.e. endianness), whether to use 32-bit or 64-bit addresses, and the type of the ELF binary.</p>

<p>There are multiple types of ELF binaries: REL (relocatable object file), DYN (representing a shared library), and EXEC (the final product).
Note that the output of the assembler before linking is a binary of type REL.
This is because at that stage, the code in the binary does not contain exact addresses.
After the linker, we should get an EXEC.
However, we are getting a ELF of type DYN.
This is because GCC, our compiler, by default enables PIE (position independent code).
This means that the addresses are not finalized yet.
The purpose of PIE is to achieve ASLR (address space layout randomization) to make it harder for bad actors to hijack the binary by knowing the exact locations of parts of the binary during runtime.</p>

<h3 id="program-headers">Program Headers</h3>

<p><img src="/images/x86BinaryBlog/programHeaders.png" alt="_config.yml" />
The purpose of the program header is to tell the OS how to load the program binary into memory and execute it.
Note that the program header is requesting a program interpreter.
Even though C is a compiled language, the compiler uses this interpreter during dynamic loading, which involve the final steps needed to complete the loading and prepare the program for execution.</p>

<h3 id="section-headers">Section Headers</h3>

<p>Sections make up segments, which are part of the program header.
Note that only the first few sections are included in the picture for brevity.</p>

<p><img src="/images/x86BinaryBlog/sectionHeaders.png" alt="_config.yml" /></p>

<p>We can see that there is a <code class="language-plaintext highlighter-rouge">Section to Segment mapping</code> section where sections are assigned to segments.</p>

<p><img src="/images/x86BinaryBlog/sectionSegmentMapping.png" alt="_config.yml" /></p>

<p>The section header contains meta data about the sections, including the location, the size and the name.
The sections are used to divide up the binary logically as described in more detail in the next section <code class="language-plaintext highlighter-rouge">Running the program</code>.
The <code class="language-plaintext highlighter-rouge">.text</code> section contains the executable code.
The <code class="language-plaintext highlighter-rouge">.data</code> section holds initialized data.
The <code class="language-plaintext highlighter-rouge">.bss</code> section holds uninitialized data.</p>

<h2 id="program-execution">Program Execution</h2>
<p>When we run the program, a process is created and the program represented by an ELF is loaded from the file into the process’s address space.
The executable file has instructions for the OS on the address space layout.
The OS looks at the ELF to load segments into memory and for invoking a user space run-time linker program.
The process’s single thread of control then executes the program’s code.
This program consists of executable code and data.
Note that the code, once loaded, is never modified.
On the other hand, much of data is modified so it makes sense to divide the two and put the code in a part of the address space that prevents modification.
We could put all data in a readable writable region but that’s not necessarily what we want.
There are global and local variables.
Global variable’s scope is the entire program.
Local variables scope is just the block and are not needed after the thread exits the local variable’s scope.
Therefore, we will have different sections for each.
These sections are described previously in the <code class="language-plaintext highlighter-rouge">Section Headers</code> part.</p>

<p>The OS also allocates the stack and the heap for the program.
The stack is used for local variables of fixed size.
We encountered this previously in the Calling Conventions Aside when analyzing the assembly code.
The heap is used for dynamic memory location and variables allocated here can be accessed globally.</p>

<h2 id="resources">Resources</h2>
<ul>
  <li><a href="https://github.com/andrew128/x86-binary-compilation-process">Code used in blog post</a></li>
  <li><a href="https://aaronbloomfield.github.io/pdr/book/x86-32bit-ccc-chapter.pdf">32 Bit x86 Calling Conventions</a></li>
  <li><a href="https://gribblelab.org/CBootCamp/7_Memory_Stack_vs_Heap.html">Stack vs Heap</a></li>
  <li>Textbook: Operating Systems in Depth</li>
  <li><a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html">Compiling, Linking, and Building C/C++ Applications</a></li>
  <li><a href="https://lwn.net/Articles/631631/">How Programs Get Run: ELF Binaries</a></li>
  <li><a href="http://bottomupcs.sourceforge.net/csbu/x3300.htm#:~:text=The%20ELF%20header%20actually%20points,into%20memory%20and%20execute%20it.">ELF Structure</a></li>
</ul>

  </div>


  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/andrew128"><i class="svg-icon github"></i></a>

<a href="https://www.linkedin.com/in/andrew-wei-272027147/"><i class="svg-icon linkedin"></i></a>






        </footer>
      </div>
    </div>

    
	<!-- Google Analytics -->
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-177211139-1', 'auto');
		ga('send', 'pageview', {
		  'page': '/x86-binary/',
		  'title': 'C Source Code to x86 Binary'
		});
	</script>
	<!-- End Google Analytics -->


  </body>
</html>
