<!DOCTYPE html>
<html>
  <head>
    <title>The Producer Consumer Problem in C++ – Andrew Wei – </title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="We will go over a solution to the Producer Consumer problem in concurrency with multiple producers and consumers in a buffer of bounded size.
The solution is written in C++ and uses mutexes and condition variables.
This post is based off of the blog post here by Baptiste Wicht.
" />
    <meta property="og:description" content="We will go over a solution to the Producer Consumer problem in concurrency with multiple producers and consumers in a buffer of bounded size.
The solution is written in C++ and uses mutexes and condition variables.
This post is based off of the blog post here by Baptiste Wicht.
" />
    
    <meta name="author" content="Andrew Wei" />

    
    <meta property="og:title" content="The Producer Consumer Problem in C++" />
    <meta property="twitter:title" content="The Producer Consumer Problem in C++" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Andrew Wei - " href="/feed.xml" />

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://avatars0.githubusercontent.com/u/8172167?s=400&u=27034bc93779390bfbaca21727973a54058fc093&v=4" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Andrew Wei</a></h1>
            <p class="site-description"></p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {
  inlineMath: [['$','$'], ['\\(','\\)']],
  processEscapes: true},
  jax: ["input/TeX","input/MathML","input/AsciiMath","output/CommonHTML"],
  extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "[Contrib]/a11y/accessibility-menu.js"],
  TeX: {
  extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"],
  equationNumbers: {
  autoNumber: "AMS"
  }
  }
  });
  </script>
<article class="post">
  <h1>The Producer Consumer Problem in C++</h1>

  <div class="date">
    Written on May 30, 2021
  </div>
  <div class="entry">
    <p>We will go over a solution to the Producer Consumer problem in concurrency with multiple producers and consumers in a buffer of bounded size.
The solution is written in C++ and uses mutexes and condition variables.
This post is based off of the blog post <a href="https://baptiste-wicht.com/posts/2012/04/c11-concurrency-tutorial-advanced-locking-and-condition-variables.html">here</a> by Baptiste Wicht.</p>

<h2 id="post-outline">Post Outline</h2>
<ul>
  <li><a href="#background">Background</a></li>
  <li><a href="#bounded-buffer">Bounded Buffer</a></li>
  <li><a href="#producer-consumer-code">Producer Consumer Code</a></li>
  <li><a href="#resources">Resources</a></li>
</ul>

<h2 id="background">Background</h2>

<h3 id="producer-consumer-problem-setup">Producer Consumer Problem Setup</h3>

<p>In the Producer Consumer problem, many producers are adding data to a data structure (i.e. buffer) that many consumers are reading from at the same time (i.e. concurrently).
The heart of the problem lies in coordinating the producers to only add data if there is space in the buffer and the consumers to only remove data from the buffer if there exists data in the buffer.</p>

<p>An initial solution to the data race problem may use while loops to check the size. 
For example, the producer may loop while the buffer is full and when there is space, exit the while loop and add data to the buffer.
However, this solution will result in data races.</p>

<p>Data races easily occur if no synchronization techniques are used because the size of the buffer needs to be updated atomically with the production and consumption of data in the buffer.
If the buffer size update is not thread safe, producers may try to add data to the buffer when it is already full and consumers may try to remove data from the buffer when the buffer is empty.</p>

<p>We will go over two synchronization primitives, <strong>mutexes</strong> and <strong>condition variables</strong>, that can be used in one possible solution to this problem.</p>

<h3 id="mutexes">Mutexes</h3>
<p>Mutexes are a synchronization primitive that prevent data races when multiple threads access the same data structure.
We can make transactions thread safe using mutexes by locking a particular block of code that we want to execute such that only one thread is accessing that block at a time.
This is done by calling <code class="language-plaintext highlighter-rouge">mutex.lock()</code> at the start of the block and <code class="language-plaintext highlighter-rouge">mutex.unlock()</code> at the end.
Typically mutexes are implemented with a queue of threads.
Threads wanting to access a thread safe block of code call <code class="language-plaintext highlighter-rouge">mutex.lock()</code> and if another thread is currently accessing that block, the thread is added to a queue from which threads are removed one at a time and run when the running thread calls <code class="language-plaintext highlighter-rouge">mutex.unlock()</code>.</p>

<p>Mutexes alone are enough to solve the data race problem discussed previously if we use the while loops to check for the buffer being empty or full and use mutexes to make the code thread safe.
However, the solution is inefficient because of the while loop, which keeps the CPU busy unnecessarily while it loops.
We can call a sleep function in intervals but ultimately this solution is still inefficient because the threads can’t talk to each other.</p>

<p>Note that with mutexes, <strong>all</strong> accesses to a shared data structure between threads must be synchronized with mutexes.
Otherwise, data races will occur.</p>

<h3 id="condition-variables">Condition Variables</h3>
<p>As a solution to the previous problem, we will introduce condition variables, which allow inter thread communication.</p>

<p>Condition variables work by making a thread wait (i.e. blocked) until it is notified to resume by another thread.
A unique lock is used to lock the calling thread that calls <code class="language-plaintext highlighter-rouge">wait()</code>.
The calling thread remains blocked until another thread calls <code class="language-plaintext highlighter-rouge">notify()</code> on the same condition variable.</p>

<p>When a calling thread calls <code class="language-plaintext highlighter-rouge">wait()</code> it must first acquire the mutex as input to <code class="language-plaintext highlighter-rouge">wait()</code>.
During <code class="language-plaintext highlighter-rouge">wait()</code>, the thread is placed on the condition variable’s queue of threads and the mutex is released.
Once the thread that is waiting is notified by another thread, it reacquires the mutex.</p>

<p>Note that the thread calling <code class="language-plaintext highlighter-rouge">notify()</code> doesn’t need to acquire the mutex of the waiting thread due to the <code class="language-plaintext highlighter-rouge">notify()</code> function itself.</p>

<h2 id="bounded-buffer">Bounded Buffer</h2>

<p>Let’s go over the header file for the <code class="language-plaintext highlighter-rouge">Buffer</code> class.
The main part of the problem is the <code class="language-plaintext highlighter-rouge">Buffer</code> data structure, which has two functions for “producing” (i.e. placing integers in the buffer) and “consuming” (i.e. removing integers from the buffer).</p>

<p>The buffer is a circular bounded buffer, meaning that it has a fixed size as defined by the macro <code class="language-plaintext highlighter-rouge">BUFFER_CAPACITY</code>.
The buffer also rotates in a circular fashion as kept track of by the left and right integer index fields of the <code class="language-plaintext highlighter-rouge">Buffer</code> class.</p>

<p>We also have a mutex for the condition variables <code class="language-plaintext highlighter-rouge">not_empty</code> and <code class="language-plaintext highlighter-rouge">not_full</code>.
Note that we have a single mutex (instead of one for each condition variable) because we want to synchronize the <code class="language-plaintext highlighter-rouge">produce()</code> and <code class="language-plaintext highlighter-rouge">consume()</code> functions.
We will go into more detail about the usage of the condition variables in the following sections.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define BUFFER_CAPACITY 10

class Buffer {
    // Buffer fields
    int buffer [BUFFER_CAPACITY];
    int buffer_size;
    int left; // index where variables are put inside of buffer (produced)
    int right; // index where variables are removed from buffer (consumed)
    
    // Fields for concurrency
    std::mutex mtx;
    std::condition_variable not_empty;
    std::condition_variable not_full;
    
public:
    // Place integer inside of buffer
    void produce(int thread_id, int num);
    
    // Remove integer from buffer
    int consume(int thread_id);
    
    Buffer();
};
</code></pre></div></div>

<h3 id="bufferproduce">Buffer::produce()</h3>

<p>The <code class="language-plaintext highlighter-rouge">produce()</code> function is where we implement the addition of data into an instance of the <code class="language-plaintext highlighter-rouge">Buffer</code> class in a thread safe manner.
At a high level, we acquire a unique lock on the mutex, which is required by condition variables (as opposed to a basic std::mutex b/c of the condition variable function signatures).</p>

<p>We then use the function <code class="language-plaintext highlighter-rouge">wait(lock, pred)</code> on the <code class="language-plaintext highlighter-rouge">not_full</code> condition variable.
We want to wait if the buffer is full and only continue if another thread notifies us that the buffer is not full anymore.
The above function signature is equivalent to (as specified in the <a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait">docs</a>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while (!pred()) {
    wait(lock);
}
</code></pre></div></div>

<p>Essentially the wait will only occur if the predicate is false.
Since we want to only wait if the buffer is full, our predicate will return true if the buffer is not full.</p>

<p>The code after the wait will only fire if the buffer is not full.
We next need to add the input to the buffer and update the appropriate fields of the <code class="language-plaintext highlighter-rouge">Buffer</code> instance, mainly the size and the right index.</p>

<p>At this point, we have finished modifying the <code class="language-plaintext highlighter-rouge">buffer</code> field and no longer need the lock, so we unlock it.</p>

<p>We then call <code class="language-plaintext highlighter-rouge">notify()</code> with the <code class="language-plaintext highlighter-rouge">not_empty</code> condition variable because the buffer can’t be empty as we have just added a value.
This will notify any waiting consumer threads that may be waiting if the <code class="language-plaintext highlighter-rouge">buffer</code> was empty.</p>

<p>Below is the full <code class="language-plaintext highlighter-rouge">produce()</code> function code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void Buffer::produce(int thread_id, int num) {
    // Acquire a unique lock on the mutex
    std::unique_lock&lt;std::mutex&gt; unique_lock(mtx);
    
    std::cout &lt;&lt; "thread " &lt;&lt; thread_id &lt;&lt; " produced " &lt;&lt; num &lt;&lt; "\n";
    
    // Wait if the buffer is full
    not_full.wait(unique_lock, [this]() {
        return buffer_size != BUFFER_CAPACITY;
    });
    
    // Add input to buffer
    buffer[right] = num;
    
    // Update appropriate fields
    right = (right + 1) % BUFFER_CAPACITY;
    buffer_size++;
    
    // Unlock unique lock
    unique_lock.unlock();
    
    // Notify a single thread that buffer isn't empty
    not_empty.notify_one();
}
</code></pre></div></div>

<h3 id="bufferconsume">Buffer::consume()</h3>

<p>We now cover the thread safe <code class="language-plaintext highlighter-rouge">consumer()</code> function of the buffer.
It is essentially the exact opposite of the <code class="language-plaintext highlighter-rouge">Buffer::produce()</code> code.
We acquire the lock and only wait if the buffer is empty.
We then remove the next value to remove from the buffer and update the appropriate fields.</p>

<p>We end by unlocking the lock, notifying any thread that might be waiting that the buffer isn’t full anymore, and returning the value we consumed.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int Buffer::consume(int thread_id) {
    // Acquire a unique lock on the mutex
    std::unique_lock&lt;std::mutex&gt; unique_lock(mtx);
    
    // Wait if buffer is empty
    not_empty.wait(unique_lock, [this]() {
        return buffer_size != 0;
    });
    
    // Get value from position to remove in buffer
    int result = buffer[left];
    
    std::cout &lt;&lt; "thread " &lt;&lt; thread_id &lt;&lt; " consumed " &lt;&lt; result &lt;&lt; "\n";
    
    // Update appropriate fields
    left = (left + 1) % BUFFER_CAPACITY;
    buffer_size--;
    
    // Unlock unique lock
    unique_lock.unlock();
    
    // Notify a single thread that the buffer isn't full
    not_full.notify_one();
    
    // Return result
    return result;
}
</code></pre></div></div>

<h2 id="producer-consumer-code">Producer Consumer Code</h2>
<p>We now write the code to actually call the <code class="language-plaintext highlighter-rouge">Buffer</code> class’s methods.
To start, we can create an instance of the <code class="language-plaintext highlighter-rouge">Buffer</code> class.
The <code class="language-plaintext highlighter-rouge">srand</code> line is simply to randomize the seed for the produce function, which adds random numbers to the buffer.</p>

<p>We then create several produce and consume threads that call <code class="language-plaintext highlighter-rouge">produceInt</code> and <code class="language-plaintext highlighter-rouge">consumeInt</code> (described below).
We finally call join on all the threads to wait for completion.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main(int argc, const char * argv[]) {
    std::cout &lt;&lt; "Executing code in main...\n";
    
    // Initialize random seed
    srand (time(NULL));
    
    // Create Buffer
    Buffer buffer;
    
    // Create a thread to produce
    std::thread produceThread0(produceInt, std::ref(buffer));
    
    std::thread consumeThread0(consumeInt, std::ref(buffer));
    
    std::thread produceThread1(produceInt, std::ref(buffer));
    
    std::thread consumeThread1(consumeInt, std::ref(buffer));
    
    std::thread produceThread2(produceInt, std::ref(buffer));
    
    produceThread0.join();
    produceThread1.join();
    produceThread2.join();
    consumeThread0.join();
    consumeThread1.join();
    
    std::cout &lt;&lt; "Done!\n";
    return 0;
}
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">produceInt()</code> function takes as input a reference to the <code class="language-plaintext highlighter-rouge">Buffer</code> class instance and generates a random number between 1 and 10 to add to the buffer, calling the buffer’s <code class="language-plaintext highlighter-rouge">produce()</code> method.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Takes in reference to a buffer and adds a random integer
void produceInt(Buffer &amp;buffer) {
    for (int i = 0; i &lt; 4; i++) {
        // Generate random number between 1 and 10
        int new_int = rand() % 10 + 1;
        buffer.produce(i, new_int);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">consumeInt()</code> function acts similarly except that it consumes a number from the buffer instead using the buffer’s <code class="language-plaintext highlighter-rouge">consume()</code> method.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Takes in reference to a buffer and returns the latest int added
// in the buffer
void consumeInt(Buffer &amp;buffer) {
    for (int i = 0; i &lt; 6; i++) {
        buffer.consume(i);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}
</code></pre></div></div>

<p>Note that the number of values produced equals the number of values consumed (otherwise the code would not complete because either a produce thread or a consume thread would be waiting for an event that would never happen).</p>

<p>Here is a sample output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Executing code in main...
thread 0 produced 7
thread 0 consumed 7
thread 0 produced 9
thread 0 consumed 9
thread 0 produced 7
thread 1 produced 5
thread 1 consumed 7
thread 1 produced 4
thread 1 consumed 5
thread 1 produced 8
thread 2 produced 10
thread 2 consumed 4
thread 2 produced 1
thread 2 consumed 8
thread 2 produced 5
thread 3 consumed 10
thread 3 consumed 1
thread 3 produced 10
thread 3 produced 7
thread 3 produced 9
thread 4 consumed 5
thread 4 consumed 10
thread 5 consumed 7
thread 5 consumed 9
Done!
Program ended with exit code: 0
</code></pre></div></div>

<h2 id="resources">Resources</h2>
<ul>
  <li><a href="https://github.com/andrew128/ProducerConsumer">Code used in this blog post</a></li>
  <li><a href="https://baptiste-wicht.com/posts/2012/04/c11-concurrency-tutorial-advanced-locking-and-condition-variables.html">Baptiste Wicht’s Blog post</a></li>
  <li><a href="https://github.com/CppCon/CppCon2020/blob/main/Presentations/back_to_basics_concurrency/back_to_basics_concurrency__arthur_odwyer__cppcon_2020.pdf">Back to Basics Concurrency Talk Slides by Arthur O’Dwyer</a></li>
  <li><a href="https://www.cplusplus.com/reference/condition_variable/condition_variable/">C++ Documentation on Condition Variables</a></li>
  <li><a href="https://levelup.gitconnected.com/producer-consumer-problem-using-condition-variable-in-c-6c4d96efcbbc">Blog Post by Domi Yan on the Producer Consumer Problem</a></li>
</ul>

  </div>


  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/andrew128"><i class="svg-icon github"></i></a>

<a href="https://www.linkedin.com/in/andrew-wei-272027147/"><i class="svg-icon linkedin"></i></a>






        </footer>
      </div>
    </div>

    
	<!-- Google Analytics -->
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-177211139-1', 'auto');
		ga('send', 'pageview', {
		  'page': '/ProducerConsumer/',
		  'title': 'The Producer Consumer Problem in C++'
		});
	</script>
	<!-- End Google Analytics -->


  </body>
</html>
