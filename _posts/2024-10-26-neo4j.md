---
layout: post
title: Intro to Neo4j (Graph Databases)
---

A primer on Graph Databases with Neo4j. 

## What are graph databases
Graph databases are 
- explain what are graph databases - the graph model
- vertices and edges

- explain the space, the problems that graph databases solve:
- graph databases are designed to represent data and answer questions that fit this graph model (e.g. social network)

Real-world applications include:
- Social networks
- Fraud detection
- Knowledge graphs
- Recommendation engines
- Supply chain optimization

## how does it compare to other technologies (i.e. sql, nosql)
- why do sql and no sql suck at representing graph data. because all the graph connections are implicitly connected.
- logic will have to exist in the application processing layer. 

- lets look at why sql is bad for representing graph and relationships
- with larger graphs one can imagine that there will be many sparse tables created and the data becomes less uniform. for example three different nodes that are different types may be represented by three different tables. the relationships between them may be able to be represented by foreign keys or another table but the point is that its not designed with graph data in mind. its meant for tabular data. 
- also a query that involves information from all three nodes will require joins

- other nosql databases (document, key value, column)
- same problem where multiple lookups have to be performed resulting in potentially new queries

- both of the above systems also begin to get super complex when we want to run graph algorithms like shortest path, finding relationships between nodes, etc.

## how do graph databases work (with neo4j specifically)
### neo 4j graph db internals
- seems like the idea of nodes and edges are how the database storage and query architecture are designed
- the query engine has node and edge indices
- in the physical storage layer there are node and edge pages that are managed by the db

- chapter 6: graph db internals
- fundamentally i think the ndoes and edges are stored separately
- show physical and logical representations of the api

- go over the different types of api exposure

- how are they durable as well

========================================

- neo4j graph db internals
- native processing + native storage for graphs
- many ways to encode and represent graph
- graph db has native processing capabilities if it has the index-free adjacency property
- index free adjacency means that each node maintains direct references to adjacent nodes (micro index as opposed to global index)
- query times are independent of total size of the graph. instead proportional to the amount of the graph searched
- non native graph db engine uses global indexes to link nodes together
^key property of graph db engines (global index free adjancency)
makes sense because you dont have to use indexes to query over the whole graph
queries can be localized to nodes

- what does native graph storage look like
- files on disk -> apis -> cypher query language
- separtate store files for a specific part of the graph (nodes, relationships, labels, properties)

NOTE: not sure i understand nodes, relationships, labels properites. i just know vertices and edges. 

- example:
labels are person in this example
properties is the key value store that both nodes and relationships can have
knows is a relationship type
```
// Create two nodes with labels and properties
CREATE (alice:Person {name: "Alice", age: 25})
CREATE (bob:Person {name: "Bob", age: 30})

// Create a relationship with properties
CREATE (alice)-[:KNOWS {since: 2020, meetAt: "Conference"}]->(bob)
```

- node representation on disk:
- node file store is a fixed size record, enables fast lookups by being able to index directly to location instead of having to perform a search
- in use (1 byte)
- id of first relationship connected to node (4 bytes)
- id of first property of the node (4 bytes)
- point to label store for this node (5 bytes)
- flags (1 byte)

^basically just a structure storing pointers to lists of relationships, labels, properties

- properties stored separately so that nodes and relationships can be fixed size which is key for performance
- to read node properties basically traverse a linked list

- to read label store probably same thing? book did note that if label was simple enough then the value would be stored right there (i.e. inlined). this is an optimization

TODO: maybe find where in the code this is stored!!! where the disk format is stored. that would be cool
Grounding in actual code: https://github.com/neo4j/neo4j/blob/bed2fa8406b29df4edde18e3d8cb471f69ce477e/community/record-storage-engine/src/main/java/org/neo4j/kernel/impl/store/format/standard/NodeRecordFormat.java
```
// Node Record Binary Format Analysis
// Total size: 15 bytes per record

/*
Binary Layout:
Byte 0 (headerByte):
    Bits 0-2: Relationship modifier (relModifier)
    Bits 4-7: Property modifier (propModifier)
    Bit 3: Unused
    
Bytes 1-4: Next Relationship ID (lower 32 bits)
Bytes 5-8: Next Property ID (lower 32 bits)
Bytes 9-12: Labels (lower 32 bits)
Byte 13: Labels (upper 8 bits)
Byte 14: Extra byte (flags, including dense node status)
*/

@Override
public void read(NodeRecord record, PageCursor cursor, RecordLoad mode, int recordSize, int recordsPerPage) {
    // Read the header byte which contains various flags and modifiers
    byte headerByte = cursor.getByte();
    
    // Check if record is in use (active)
    boolean inUse = isInUse(headerByte);
    record.setInUse(inUse);
    
    // Only load full record if needed based on mode
    if (mode.shouldLoad(inUse)) {
        // Read next relationship ID (32 bits)
        long nextRel = cursor.getInt() & 0xFFFFFFFFL;  // Unsigned conversion
        
        // Read next property ID (32 bits)
        long nextProp = cursor.getInt() & 0xFFFFFFFFL; // Unsigned conversion
        
        // Extract high bits for relationship and property IDs from header
        long relModifier = (headerByte & 0xEL) << 31;  // Bits 1-3 shifted to high positions
        long propModifier = (headerByte & 0xF0L) << 28; // Bits 4-7 shifted to high positions
        
        // Read label field (40 bits total)
        long lsbLabels = cursor.getInt() & 0xFFFFFFFFL;  // Lower 32 bits
        long hsbLabels = cursor.getByte() & 0xFF;        // Upper 8 bits
        long labels = lsbLabels | (hsbLabels << 32);     // Combine into 40-bit value
        
        // Read extra flags byte
        byte extra = cursor.getByte();
        boolean dense = (extra & 0x1) > 0;  // First bit indicates dense node status
        
        // Initialize the record with all read values
        record.initialize(
            inUse,
            BaseRecordFormat.longFromIntAndMod(nextProp, propModifier), // Combine property ID parts
            dense,
            BaseRecordFormat.longFromIntAndMod(nextRel, relModifier),   // Combine relationship ID parts
            labels
        );
    } else {
        // If we don't need the record data, skip to next record
        int nextOffset = cursor.getOffset() + recordSize - HEADER_SIZE;
        cursor.setOffset(nextOffset);
    }
}

/*
Key Points:
1. IDs (nextRel, nextProp) are split into:
   - 32 bits in main section
   - Additional bits in header byte
   This allows for larger IDs while maintaining backward compatibility

2. Labels field is 40 bits:
   - 32 bits lower section
   - 8 bits upper section
   Allowing for a large number of labels per node

3. Dense node flag:
   - Used for nodes with many relationships
   - Changes how relationships are stored
   
4. Performance optimization:
   - Fixed record size enables direct seeking
   - Minimal bit manipulation for common operations
   - Header byte provides quick access to status flags
*/
```

- relationships: 
stored in relationship store file, also contains fixed size records
- contains nodes of start and end of relationship
- pointer to relationship type which is stored in relationship store
- pointer for next and previous relationship stores for each of start and end nodes
- flag indicating whether current record is first in a "relationship chain"

NOTE: understand how this relationship chain works. not sure i understand. 
- how nodes are read, graphs are traversed between nodes and through relationships

- a relationship chain record is maintaining two separate doubly linked lists for each relationship
- that makes sense
- and to traverse you start with a node which contains the reference to its first relationship. 

----------
### Neo4j APIs
- THEN understand the apis/cypher

- cypher - declarative query language (don't know anyhting about the implementation, just describes what you want)
- kernel api - very low level, can be used to listen to db transactions
- core api - imperative java api that describes exactly how to get it. exposes graph primitives of nodes, relationships, properties, labels
- traversal framework - declarative java api

what api to choose:
- cypher can't always craft a more complex algorithm
- traversal framework vs core api - traversal framework is higher level, core api gives more control but will be more verbose
- kernel api - transaction even handlers - can react in response to transactions

### Neo4j db properties
- then understand other db properites

- use LRU-K page cache which divides each store into discrete regions and holds a fixed number of regions per store file
- pages are evicted from cache based on least frequently used policy and page popularity


##  Neo4j Code Example
- set up an example data model
- show how to use it

- cypher is the sql syntax esque query language that is used in neo4j

- create an example interesting data model

- examples of queries and problems that these graphs can solve
- show a couple concrete examples and compare to how sql or no sql would have to do it (like shortest path, etc.)
- chapter 7 - predictive analysis with graph theory. show some examples

-------------
just set up example data model

show how to use it

```
// First, let's clear the database to start fresh
MATCH (n) DETACH DELETE n;

// Create movie nodes
CREATE (inception:Movie {
    title: "Inception",
    released: 2010,
    tagline: "Your mind is the scene of the crime"
});

CREATE (darkKnight:Movie {
    title: "The Dark Knight",
    released: 2008,
    tagline: "Why so serious?"
});

// Create actor nodes
CREATE (leonardo:Person {
    name: "Leonardo DiCaprio",
    born: 1974
});

CREATE (christianBale:Person {
    name: "Christian Bale",
    born: 1974
});

CREATE (chrisNolan:Person {
    name: "Christopher Nolan",
    born: 1970
});

// Create relationships
MATCH (leonardo:Person {name: "Leonardo DiCaprio"})
MATCH (inception:Movie {title: "Inception"})
CREATE (leonardo)-[:ACTED_IN {roles: ["Cobb"]}]->(inception);

MATCH (christianBale:Person {name: "Christian Bale"})
MATCH (darkKnight:Movie {title: "The Dark Knight"})
CREATE (christianBale)-[:ACTED_IN {roles: ["Bruce Wayne"]}]->(darkKnight);

MATCH (chrisNolan:Person {name: "Christopher Nolan"})
MATCH (inception:Movie {title: "Inception"})
MATCH (darkKnight:Movie {title: "The Dark Knight"})
CREATE (chrisNolan)-[:DIRECTED]->(inception),
       (chrisNolan)-[:DIRECTED]->(darkKnight);

// Query to see all movies and their directors
MATCH (director:Person)-[:DIRECTED]->(movie:Movie)
RETURN director.name, movie.title;

// Query to see all actors and their roles
MATCH (actor:Person)-[role:ACTED_IN]->(movie:Movie)
RETURN actor.name, role.roles, movie.title;
```


# Areas for further exploration
- how are graph dbs used as knowledge graphs (neo4j gen ai applications)
- how Tao (Facebook's Graph storage) works
- core DB concepts that neo4j uses
    - LRU K cache
    - WAL log - how transactions are implemented, this area, durability
    - lock manager, page cache, record files, transaction log, transaction management
    - ACID transactions
    - availability, replication

# Resources
- Neo4j O'Reilly book